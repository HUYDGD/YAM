"use strict";

/**
 * @event
 * Handles errors generated by the application.
 * @param {String} message Error message
 * @param {String} source File where the error occurred
 * @param {number} lineno Line containing the instruction that generated the error
 * @param {number} colno Column containing the statement that generated the error
 * @param {Error} error Application generated error
 */
window.onerror = function (message, source, lineno, colno, error) {
    window.EM.onerror("main-renderer.js", {
        message: message,
        line: lineno,
        column: colno,
        error: error,
    });
};

/**
 * @event
 * Handles errors generated within non-catched promises.
 * @param {PromiseRejectionEvent} error 
 */
window.onunhandledrejection = function (error) {
    window.EM.unhandlederror("main-renderer.js", error.reason);
};

//#region Events
document.addEventListener("DOMContentLoaded", onDOMContentLoaded);

document.querySelector("#search-game-name").addEventListener("keyup", onSearchGameName);

document.querySelector("#user-info").addEventListener("login", login);

document.querySelector("#add-remote-game-btn").addEventListener("click", onAddRemoteGame);

document.querySelector("#add-local-game-btn").addEventListener("click", onAddLocalGame);

document.querySelector("#settings-password-toggle").addEventListener("click", onPasswordToggle);

document.querySelector("#settings-reset-update-cache-btn").addEventListener("click", onDeleteUpdateCache);

document.querySelector("#settings-show-devtools-btn").addEventListener("click", onShowDevTools);

document.querySelector("#settings-menubar-checkbox").addEventListener("change", onEnableMenuBar);

document.querySelector("#settings-open-links-checkbox").addEventListener("change", onOpenLinksInExternalBrowser);

document.querySelector("#settings-save-credentials-btn").addEventListener("click", onSaveCredentialsFromSettings);

document.querySelector("#main-language-select").addEventListener("change", updateLanguage);

document.querySelector("#main-navbar-games").addEventListener("click", openPage);

document.querySelector("#main-navbar-updated-threads").addEventListener("click", openPage);

document.querySelector("#main-navbar-recommendations").addEventListener("click", openPage);

document.querySelector("#main-navbar-settings").addEventListener("click", openPage);

//#region Events listeners

/**
 * Initialize and perform preliminary operations once the DOM is fully loaded.
 */
async function onDOMContentLoaded() {
    // This function runs when the DOM is ready, i.e. when the document has been parsed
    window.API.log.info("DOM loaded, initializing elements");
    await translateElementsInDOM()
        .catch(e => window.API.reportError(e, "11200", "translateElementsInDOM", "onDOMContentLoaded"));
    await listAvailableLanguages()
        .catch(e => window.API.reportError(e, "11201", "listAvailableLanguages", "onDOMContentLoaded"));

    // Initialize the navigator-tab
    const tabNavigator = document.getElementById("tab-navigator");
    // eslint-disable-next-line no-undef
    M.Tabs.init(tabNavigator, {});

    // Initialize the floating button
    const fabs = document.querySelectorAll(".fixed-action-btn");
    // eslint-disable-next-line no-undef
    M.FloatingActionButton.init(fabs, {
        direction: "left",
        hoverEnabled: false,
    });

    // Initialize the <select> for languages
    const selects = document.querySelectorAll("select");
    // eslint-disable-next-line no-undef
    M.FormSelect.init(selects, {});

    // Set link to logs directory
    const cacheDir = await window.API.invoke("user-data");
    const logsDir = window.API.join(cacheDir, "logs");
    document.getElementById("main-open-log-folder-btn").setAttribute("href", logsDir);

    // Set version value
    const appVersion = await window.API.invoke("app-version");
    const translation = await window.API.translate("MR app version", {
        "version": appVersion
    });
    document.getElementById("main-version").textContent = translation;

    // Login to F95Zone
    await login()
        .catch(e => window.API.reportError(e, "11202", "login", "onDOMContentLoaded"));

    // Load cards in the paginator
    const paginator = document.querySelector("card-paginator");
    paginator.playListener = gameCardPlay;
    paginator.updateListener = gameCardUpdate;
    paginator.deleteListener = gameCardDelete;
    
    // Get the size of the window and load in 
    // the paginator a variable number of cards
    // based on this size
    window.API.receive("window-size", paginator.visibleCardsOnParentSize);
    window.API.send("window-size");
    
    // Load credentials
    await loadCredentials()
        .catch(e => window.API.reportError(e, "11203", "loadCredentials", "onDOMContentLoaded"));
}

/**
 * Displays games whose titles contain the value the user entered in the search box.
 * @param {KeyboardEvent} e
 */
function onSearchGameName(e) {
    // Search only if the user press "enter"
    if(e.key !== "Enter") return;

    // Obtain the text
    const searchText = document
        .getElementById("search-game-name")
        .value;

    document.querySelector("card-paginator").search(searchText);
}

/**
 * @private
 * Ask the user to select a single folder on disk.
 * @returns {Promise<String>} Path to selected folder
 */
async function selectSingleGameFolder() {
    const gameFolderPaths = await selectGameDirectories(false)
        .catch(e => window.API.reportError(e, "11204", "selectGameDirectories", "selectSingleGameFolder"));
    if (gameFolderPaths.length !== 0) return gameFolderPaths.pop();
}

/**
 * Adds an undetectable game on the PC via the game URL.
 */
async function onAddRemoteGame() {
    // Local variables
    let toastGamename = null;
    let toastType = null;
    let toastKey = null;

    // The user select a single folder and a URL
    const gamePath = await selectSingleGameFolder();
    const url = await window.API.invoke("url-input");
    if (!gamePath || !url) return;

    const translationAdding = await window.API.translate("MR adding game from url");
    sendToastToUser("info", translationAdding);

    // Get directory information
    const dirInfo = getDirInfo(gamePath);

    // Get game info and check if already installed
    const gameinfo = await window.F95.getGameDataFromURL(url)
        .catch(e => window.API.reportError(e, "11205", "window.F95.getGameDataFromURL", "onAddRemoteGame", `URL: ${url}`));
    const entry = await window.GameDB.count({id: gameinfo.id})
        .catch(e => window.API.reportError(e, "11206", "window.GameDB.count", "onAddRemoteGame"));

    if(entry === 0) {
        // Add data to the parsed game info
        const converted = window.GIE.convert(gameinfo);
        converted.version = dirInfo.version;
        converted.gameDirectory = dirInfo.path;

        // Save data to database
        await window.GameDB.insert(converted)
            .catch(e => window.API.reportError(e, "11207", "window.GameDB.insert", "onAddRemoteGame"));

        toastGamename = converted.name;
        toastKey = "MR game successfully added";
        toastType = "info";

        // Reload data in the paginator
        document.querySelector("card-paginator").reload();
    }

    toastGamename = toastGamename ?? gameinfo.name;
    toastKey = toastKey ?? "MR game already listed";
    toastType = toastType ?? "warning";
    
    const translation = await window.API.translate(toastKey, {
        "gamename": toastGamename
    });
    sendToastToUser(toastType, translation);
}

/**
 * Add one or more games on the PC.
 */
async function onAddLocalGame() {
    // The user select a single folder
    const gameFolderPaths = await selectGameDirectories(true)
        .catch(e => window.API.reportError(e, "11208", "selectGameDirectories", "onAddLocalGame"));
    if (gameFolderPaths.length !== 0) {
        // Obtain the data
        const translation = await window.API.translate("MR adding game from path");
        sendToastToUser("info", translation);
        await getGameFromPaths(gameFolderPaths)
            .catch(e => window.API.reportError(e, "11209", "getGameFromPaths", "onAddLocalGame"));

        // Reload data in the paginator
        document.querySelector("card-paginator").reload();
    }
}

/**
 * Show or hide the password when the user presses the appropriate button.
 */
function onPasswordToggle() {
    // Show/hide the password
    const input = document.getElementById("settings-password-txt");
    const icon = document.querySelector("#settings-password-toggle > i.material-icons");

    if (input.type === "password") {
        input.type = "text";
        icon.classList.remove("md-visibility");
        icon.classList.add("md-visibility_off");
    }
    else {
        input.type = "password";
        icon.classList.remove("md-visibility_off");
        icon.classList.add("md-visibility");
    }
}

/**
 * Delete the update cache.
 */
async function onDeleteUpdateCache() {
    // Obtains all the games in the DB
    const updates = await window.UpdateDB.search({});

    // Fetch the list of IDs
    const ids = updates.map(u => u.id);

    // Delete the records
    await window.UpdateDB.delete({id: {$in: ids}})
        .catch(e => window.API.reportError(e, "11240", "window.UpdateDB.delete", "onDeleteUpdateCache"));

    const translation = await window.API.translate("MR update cache deleted");
    sendToastToUser("info", translation);
}

/**
 * Used when the user click on the button to show the devtools.
 */
function onShowDevTools() {
    window.API.send("show-devtools");
}

/**
 * Enable or disable the menubar in production mode.
 * @param {*} e 
 */
function onEnableMenuBar(e) {
    window.API.send("allow-menubar", e.target.checked);
}

/**
 * Switch between open the links in-app in the 
 * default browser or to only copy the link.
 * @param {*} e 
 */
function onOpenLinksInExternalBrowser(e) {
    window.API.send("open-copy-links", e.target.checked);
}

/**
 * Save the credentials when the user changes them in the 'settings' tab.
 */
async function onSaveCredentialsFromSettings() {
    const credPath = await window.API.invoke("credentials-path");
    const username = document.getElementById("settings-username-txt").value;
    const password = document.getElementById("settings-password-txt").value;

    const credentials = {
        username: username,
        password: password,
    };
    const json = JSON.stringify(credentials);
    await window.IO.write(credPath, json);
    const translation = await window.API.translate("MR credentials edited");
    sendToastToUser("info", translation);
}

/**
 * Triggered when the user select a language from the <select> element.
 * Change the language for the elements in the DOM.
 */
async function updateLanguage() {
    // Parse user choice
    const e = document.getElementById("main-language-select");
    const selectedISO = e.options[e.selectedIndex].value;

    // Change language via IPC
    await window.API.changeLanguage(selectedISO)
        .catch(e => window.API.reportError(e, "11210", "window.API.changeLanguage", "updateLanguage", `ISO: ${selectedISO}`));

    // Refresh strings
    await translateElementsInDOM()
        .catch(e => window.API.reportError(e, "11211", "translateElementsInDOM", "updateLanguage"));
}

/**
 * Select the tab with the specified ID in DOM.
 * @param {MouseEvent} e
 */
function openPage(e) {
    // Local variables
    const tabcontent = document.getElementsByClassName("tabcontent");
    const fab = document.querySelector("#fab-add-game-btn");

    // Get the ID of the div to show
    const id = `${e.target.id.replace("navbar-", "")}-tab`;

    // Use requestAnimationFrame to reduce rendering time
    // see: https://stackoverflow.com/questions/37494330/display-none-in-a-for-loop-and-its-affect-on-reflow
    window.requestAnimationFrame(function () {
        // Hide the unused tabs
        for (const tab of tabcontent) tab.style.display = "none";

        // Show the specific tab content
        document.getElementById(id).style.display = "block";

        // Hide/show the add game button
        const display = id === "main-games-tab" && window.F95.logged ? "block": "none";
        fab.style.display = display;
    });
}
//#endregion

//#endregion Events

//#region Private methods

//#region Language
/**
 * @private
 * Translate the DOM elements in the current language.
 */
async function translateElementsInDOM() {
    // Get only the localizable elements
    const elements = document.querySelectorAll(".localizable");

    // Translate elements
    for (const e of elements) {
        // Select the element to translate (the last child or the element itself)
        const toTranslate = e.lastChild ?? e;
        toTranslate.textContent = await window.API.translate(e.id);
    }
}

/**
 * @private
 * Select all the available languages for the app and create a <select>.
 */
async function listAvailableLanguages() {
    // Read all the available languages
    const cwd = await window.API.invoke("cwd");
    const langs = await window.IO.filter(
        "*.json",
        window.API.join(cwd, "resources", "lang")
    );
    const currentLanguageISO = (await window.API.currentLanguage()).toUpperCase();

    for (const lang of langs) {
        const iso = lang.replace(".json", "");

        // Create <option> for the combobox
        const option = document.createElement("option");
        option.setAttribute("class", "left"); // Icons on the left
        option.setAttribute("value", iso);
        const flagPath = window.API.join(
            cwd,
            "resources",
            "images",
            "flags",
            `${iso}.webp`
        );
        option.setAttribute("data-icon", flagPath);
        option.textContent = iso.toUpperCase();

        // If current language make the option selected
        if (currentLanguageISO === iso.toUpperCase()) {
            option.setAttribute("selected", "");
        }

        // Add the option
        document.getElementById("main-language-select").appendChild(option);
    }
}
//#endregion Language

//#region Utility
/**
 * @private
 * Given a game name, remove all the special characters and various tag (*[tag]*).
 * @param {String} name
 * @returns {String}
 */
function cleanGameName(name) {
    // Remove mod tag and version
    const rxTags = /\[(.*?)\]/gu;
    const rxSpecials = /[/\\?%*:|"<>]/gu;
    return name.replace(rxTags, "").replace(rxSpecials, "").trim();
}

/**
 * @private
 * Show a toast in the top-right of the screen.
 * @param {String} type Type of message: `info`, `warning`, `error`
 * @param {String} message Message to the user
 */
function sendToastToUser(type, message) {
    // Local variables
    const settings = {
        info: {
            icon: "info",
            htmlColor: "blue",
            timer: 3000,
        },
        warning: {
            icon: "warning",
            htmlColor: "orange",
            timer: 10000,
        },
        error: {
            icon: "error_outline",
            htmlColor: "red",
            timer: 15000,
        },
    };
    
    // Select various data based on the type of message
    const data = settings[type];

    // Create and show the toast
    const htmlToast = `<i class='material-icons md-${data.icon}' style='padding-right: 10px'></i><span>${message}</span>`;
    // eslint-disable-next-line no-undef
    M.toast({
        html: htmlToast,
        displayLength: data.timer,
        classes: data.htmlColor,
    });
}

/**
 * @private
 * Load the credentials from disk.
 * @return {Promise<Object.<string, string>>}
 */
async function getCredentials() {
    // Get path
    const credPath = await window.API.invoke("credentials-path");
    const exists = await window.IO.pathExists(credPath);
    if (!exists) return null;

    // Parse credentials
    const json = await window.IO.read(credPath);
    return JSON.parse(json);
}
//#endregion Utility

//#region Authentication
/**
 * @private
 * Load credentials in the settings input fields.
 */
async function loadCredentials() {
    // Load credentials
    const credentials = await getCredentials()
        .catch(e => window.API.reportError(e, "11212", "getCredentials", "loadCredentials"));
    if(credentials) {
        // Set values
        document.getElementById("settings-username-txt").value = credentials.username;
        document.getElementById("settings-password-txt").value = credentials.password;

        // "Select" the textboxes to not overlap textual values and placeholder text
        document
            .querySelector("label[for='settings-username-txt']")
            .classList.add("active");
        document
            .querySelector("label[for='settings-password-txt']")
            .classList.add("active");
    }
}

/**
 * @private
 * Check if the user is online and if not notificate the user.
 * @return {Promise<Boolean>}
 */
async function checkIfOnline() {
    const online = await window.API.isOnline()
        .catch(e => window.API.reportError(e, "11213", "window.API.isOnline", "checkIfOnline"));

    if (!online) {
        window.API.log.warn("No network connection, cannot login");
        const translation = await window.API.translate("MR no network connection");
        sendToastToUser("warning", translation);

        // Hide spinner
        document.getElementById("user-info").hideSpinner();
    }
    return online;
}

/**
 * @private
 * Require to login to F95Zone to the main process.
 * @return {Promise<Boolean>} Result of authentication
 */
async function requireLogin() {
    // Local variables
    let returnValue = true;

    // Request user input
    window.API.log.info("Send API to main process for auth request");
    const result = await window.API.invoke("login-required");

    window.API.log.info(`Authentication result: ${result}`);
    if (result !== "AUTHENTICATED") {
        // Hide "new game" button
        document.querySelector("#fab-add-game-btn").style.display = "none";

        // Hide spinner
        document.getElementById("user-info").hideSpinner();
        returnValue = false;
    }
    return returnValue;
}

/**
 * @private
 * It checks if a network connection is available
 * and notifies the main process to perform
 * the login procedure.
 */
async function login() {
    // Show the spinner in the avatar component
    document.getElementById("user-info").showSpinner();

    // Check network connection, then login
    const online = await checkIfOnline();
    if(online) {
        const login = await requireLogin();

        if(login) {
            // Login for this session
            const credentials = await getCredentials();
            const res = await window.F95.login(credentials.username, credentials.password, window.API.retrieveCaptchaToken)
                .catch(e => window.API.reportError(e, "11214", "window.F95.login", "login"));
            if (!res.success) return;

            const translation = await window.API.translate("MR login successful");
            sendToastToUser("info", translation);

            // Show "new game" button
            document.querySelector("#fab-add-game-btn").style.display = "block";

            // Load user data
            getUserDataFromF95()
                .catch(e => window.API.reportError(e, "11215", "getUserDataFromF95", "login"));
            window.API.send("window-size");
        }
    }
}
//#endregion Authentication

//#region Adding game
/**
 * @private
 * Obtains information about a game directory.
 * @param {String} path 
 */
function getDirInfo(path) {
    // Get dir name
    const unparsedName = window.API.basename(path);

    // Get dir info
    const name = cleanGameName(unparsedName);
    const version = getGameVersionFromName(unparsedName);
    const includeMods = unparsedName.toUpperCase().includes("[MOD]");

    return {
        path: path,
        name: name,
        version: version,
        mod: includeMods
    };
}

/**
 * @private
 * Let the user select one (or more) directory containing games.
 * @param {Boolean} multipleSelection If the user can select more than one directory
 * @returns {Promise<String[]>} List of directories
 */
async function selectGameDirectories(multipleSelection) {
    // Local variables
    const props = ["openDirectory"];
    if (multipleSelection) props.push("multiSelections");

    // The user selects one (or more) folders
    const openDialogOptions = {
        title: await window.API.translate("MR select game directory"),
        properties: props,
    };
    const data = await window.API.invoke("open-dialog", openDialogOptions);

    // No folder selected, notificate the user
    if (data.filePaths.length === 0) {
        const translation = await window.API.translate("MR no directory selected");
        sendToastToUser("warning", translation);
    }

    // Check if the game(s) is already present
    return await getUnlistedGamesInArrayOfPath(data.filePaths)
        .catch(e => window.API.reportError(e, "11216", "getUnlistedGamesInArrayOfPath", "selectGameDirectories", `Paths: ${data.filePaths}`));
}

/**
 * @event
 * Start the game when the user presses the button.
 * @param {CustomEvent} e Contains the path to the game executable with the name `launcher`
 */
async function gameCardPlay(e) {
    if (!e.target) return;
    const launcherPath = e.detail.launcher;

    // Check if the path exists
    const exists = await window.IO.pathExists(launcherPath);
    if (!exists) {
        const translation = await window.API.translate("MR cannot find game path");
        window.API.log.error(`Cannot find game path: ${launcherPath}`);
        sendToastToUser("error", translation);
        return;
    }

    // Launch the game
    window.API.send("exec", launcherPath);
}

/**
 * @event
 * Start the game update process when the user presses the button.
 * @param {CustomEvent} e Contains the following information: 
 * `name`, `version`, `changelog`, `url`, `gameDirectory`
 */
async function gameCardUpdate(e) {
    // Let the user update the game
    const finalized = await window.API.invoke("update-messagebox", {
        title: e.detail.name,
        version: e.detail.version,
        changelog: e.detail.changelog,
        url: e.detail.url,
        folder: e.detail.gameDirectory
    });

    // The user has completed the procedure
    if(finalized) {
        // Finalize the update
        const result = await e.target.update()
            .catch(e => window.API.reportError(e, "11217", "e.target.update", "gameCardUpdate"));
    
        if (!result) {
            const translationError = await window.API.translate("MR error finalizing update");
            sendToastToUser("error", translationError);
            window.API.log.error("Cannot finalize the update, please check if another directory of the game exists");
        }
    }
}

/**
 * @private
 * Ask the user to confirm the game deletion.
 * @param {Boolean} savesExists True if savefiles exist for the to-be-deleted game
 * @returns {Promise<Object.<string, object>|null>} 
 * Button pressed and checkboxes selected or `null` if the user select "cancel"
 */
async function askUserForGameDeletion(savesExists) {
    // Prepare the options for the confirmation dialog
    const dialogOptions = {
        type: "warning",
        title: await window.API.translate("MR confirm deletion"),
        message: await window.API.translate("MR message confirm deletion"),
        buttons: [
            {name: "remove-only"},
            {name: "delete"},
            {name: "cancel"},
        ],
    };

    // Add option for save savefiles
    if (savesExists) dialogOptions.checkboxes = [{ name: "preserve-savegame" }];

    // Prompt user
    let data = await window.API.invoke("require-messagebox", dialogOptions);
    if (data?.button === "cancel") data = null;
    return data;
}

/**
 * @private
 * Copy the savefiles of a game into a new directory
 * @param {String[]} sources List of savefile paths
 * @param {String} gamename Name of the game
 */
async function copySaveFiles(sources, gamename) {
    // Create the directory
    const exportedSavesDir = await window.API.invoke("savegames-data-dir");
    const gameDirectory = window.API.join(exportedSavesDir, cleanGameName(gamename));
    await window.IO.mkdir(gameDirectory);

    // Copy the saves
    for (const path of sources) {
        const name = window.API.basename(path);
        const newName = window.API.join(gameDirectory, name);
        await window.IO.copy(path, newName);
    }
}

/**
 * @event
 * Start the procedure for deleting the game, 
 * allowing you to copy the game saves if possible.
 * @param {CustomEvent} e Contains the following information: 
 * `name`, `savePaths`
 */
async function gameCardDelete(e) {
    // Local variables
    const savesExists = e.detail.savePaths.length !== 0;

    // First check if the path exists
    const exists = await window.IO.pathExists(e.detail.gameDirectory);
    if (!exists) {
        // Notificate the user
        const translation = await window.API.translate("MR cannot find game path");
        sendToastToUser("error", translation);
        return;
    }

    // Ask the user for confirm
    const data = await askUserForGameDeletion(savesExists);
    if(data) {
        // Copy saves
        if (savesExists && data.checkboxes.includes("preserve-savegame")) {
            await copySaveFiles(e.detail.savePaths, e.detail.name);
        }

        // Delete also game files
        if (data.button === "delete") {
            const gameDirectory = e.detail.gameDirectory;
            await window.IO.deleteFolder(gameDirectory);
        }

        // Remove the game data
        await e.target.deleteData()
            .catch(e => window.API.reportError(e, "11218", "e.target.deleteData", "gameCardDelete"));

        // Reload data in the paginator
        document.querySelector("card-paginator").reload();

        // Notificate the user
        const translation = await window.API.translate("MR game removed", {
            gamename: e.detail.name
        });
        sendToastToUser("info", translation);
    }
}

/**
 * @private
 * Given a directory listing, it gets information about the games contained in them.
 * @param {String[]} paths Path of the directories containg games
 */
async function getGameFromPaths(paths) {
    // Parse the game dir name(s)
    for (const path of paths) {
        try {
            await getGameFromPath(path);
        }
        catch (error) {
            // Send error message
            window.API.invoke("require-messagebox", {
                type: "error",
                title: "Unexpected error",
                message: `Cannot retrieve game data (${path}), unexpected error: ${error}`,
                buttons: [{
                    name: "close"
                }]
            });
            window.API.reportError(error, "11219", "getGameFromPath", "getGameFromPaths", `Game data path: ${path}`);
        }
    }
}

/**
 * @private
 * Fetch the game that match the requisites or force the user to select one.
 * @param {String} name Name of the game
 * @param {String} version Version of the game
 * @param {Boolean} mod If the game is a mod
 * @return {GameInfo} Information of the game
 */
async function selectSingleGame(name, version, mod) {
    // Local variables
    let selectedGame = null;

    // Search and add the game
    const gamelist = await window.F95.getGameData(name, mod)
        .catch(e => window.API.reportError(e, "11220", "window.F95.getGameData", "selectSingleGame", `Name: ${name}, Is mod: ${mod}`));

    if (gamelist.length === 0) {
        const translation = await window.API.translate("MR no game found", {
            "gamename": name
        });
        sendToastToUser("warning", translation);
        window.API.log.warn(`No results found for ${name}`);
    } else if (gamelist.length > 1) {
        // Force the user to select only a game
        const message = mod ? `${name} (${version}) [MOD]` : `${name} (${version})`;
        selectedGame = await requireUserToSelectGameWithSameName(message, gamelist)
            .catch(e => window.API.reportError(e, "11221", "requireUserToSelectGameWithSameName", "selectSingleGame"));
    } else selectedGame = gamelist[0];
    
    return selectedGame;
}

/**
 * @private
 * Given a directory path, parse the dirname, get the
 * game (if exists) info and add a *game-card* in the DOM.
 * @param {String} path Game directory path
 */
async function getGameFromPath(path) {
    // Local variables
    let messageType = "warning";
    let translationKey = "MR game already listed";

    // Get directory information
    const dirInfo = getDirInfo(path);

    // Select the game
    const selectedGame = await selectSingleGame(dirInfo.name, dirInfo.version, dirInfo.mod);
    if(selectedGame) {
        // Verify that the game is not in the database
        const entry = await window.GameDB.count({
            id: selectedGame.id
        }).catch(e => window.API.reportError(e, "11222", "window.GameDB.count", "getGameFromPath"));

        if (entry === 0) {
            // Add data to the parsed game info
            const converted = window.GIE.convert(selectedGame);
            converted.version = dirInfo.version;
            converted.gameDirectory = dirInfo.path;

            // Save data to database
            await window.GameDB.insert(converted)
                .catch(e => window.API.reportError(e, "11223", "window.GameDB.insert", "getGameFromPath"));

            messageType = "info";
            translationKey = "MR game successfully added";
        }

        // Notificate the user
        const translation = await window.API.translate(translationKey, {
            "gamename": selectedGame.name
        });
        sendToastToUser(messageType, translation);
    }
}

/**
 * @private
 * Given a non-parsed game name, extract the version if a tag **[v.version]** is specified.
 * @example [v.1.2.3.4], [V.somevalue]
 * @param {String} name
 */
function getGameVersionFromName(name) {
    // Local variables
    let version = "Unknown";
    const PREFIX_VERSION = "[V."; // i.e. namegame [v.1.2.3.4]

    // Search the version tag, if any
    if (name.toUpperCase().includes(PREFIX_VERSION)) {
        const startIndex = name.toUpperCase().indexOf(PREFIX_VERSION) + PREFIX_VERSION.length;
        const endIndex = name.indexOf("]", startIndex);
        version = name.substr(startIndex, endIndex - startIndex);
    }
    return version;
}

/**
 * @private
 * Obtains all the installed game names and return them in uppercase.
 */
async function getUppercaseInstalledGameNames() {
    // Fetch the games
    const games = await window.GameDB.search({})
        .catch(e => window.API.reportError(e, "11224", "window.GameDB.search", "getUppercaseInstalledGameNames"));

    // Uppercase and return
    const returnArray = [];
    for(const game of games) {
        const gamename = cleanGameName(game.name).toUpperCase();
        returnArray.push(gamename);
    }
    return returnArray;
}

/**
 * @private
 * Given a list of paths, return a list of string containing the paths 
 * of non-installed games and a list of installed game names.
 * @param {String[]} paths Listo of paths to check
 * @param {String[]} installedGameNames Uppercase names of the installed games
 */
function separateNewAndPresentGames(paths, installedGameNames) {
    // Local variables
    const nonInstalledPaths = [];
    const installedNames = [];
    for (const path of paths) {
        // Get the clean game name
        const unparsedName = window.API.basename(path);
        const gamename = cleanGameName(unparsedName);

        // Check if it's not already present and add it to the list
        const included = installedGameNames.includes(gamename.toUpperCase());
        if (!included) nonInstalledPaths.push(path);
        else installedNames.push(gamename);
    }

    return {
        paths: nonInstalledPaths,
        names: installedNames
    };
}

/**
 * @private
 * Show the user the name of the already installed games or, if too many, only the total count.
 * @param {String[]} duplicateGameNames Duplicata game names to notificate to the user
 */
async function notificateUserOfAlreadyInstalledGames(duplicateGameNames) {
    // Local variables
    const MAX_NUMBER_OF_PRESENT_GAMES_FOR_MESSAGES = 5;

    if (duplicateGameNames.length <= MAX_NUMBER_OF_PRESENT_GAMES_FOR_MESSAGES) {
        // List the game names only if there are few duplicated games
        for (const gamename of duplicateGameNames) {
            // This game is already present: ...
            const translation = await window.API.translate("MR game already listed", {
                "gamename": gamename
            });
            sendToastToUser("warning", translation);
        }
    } else {
        const translation = await window.API.translate("MR multiple duplicate games", {
            "number": duplicateGameNames.length
        });
        sendToastToUser("warning", translation);
    }
}

/**
 * @private
 * Check that the specified paths do not belong to games already in the application.
 * @param {String[]} paths List of game paths to check
 * @returns {Promise<String[]>} List of valid paths
 */
async function getUnlistedGamesInArrayOfPath(paths) {
    // Check if the games are already present
    const installedGameNames = await getUppercaseInstalledGameNames();

    // Obtains the path of new games and the name of already installed games
    const data = separateNewAndPresentGames(paths, installedGameNames);

    // Notificate the user of duplicate games
    await notificateUserOfAlreadyInstalledGames(data.names);

    return data.paths;
}

/**
 * @private
 * Let the user select their favorite game in case of multiple search results.
 * @param {String} desiredGameName Name of the game searched
 * @param {GameInfo[]} listOfGames List of games to choose from
 * @returns {Promise<GameInfo|null>} Game selected or `null` if the user has not selected anything
 */
async function requireUserToSelectGameWithSameName(desiredGameName, listOfGames) {
    // Local variables
    const buttonsList = [];
    let entryList = "";

    // Prepares the list of games to show to the user and buttons to show on the messagebox
    for(let i = 0; i < listOfGames.length; i++) {
        const game = listOfGames[i];
        entryList = entryList.concat(`${i + 1} - ${game.name} [${game.author}] [${game.version}]\n`);

        const button = {
            name: game.id,
            text: await window.API.translate("MR select game option", {
                "number": i + 1
            }),
            classes: ["neutral-button"]
        };
        buttonsList.push(button);
    }
    buttonsList.push({name: "close"}); // Add the default close button

    // Let the user select the preferred game
    const result = await window.API.invoke("require-messagebox", {
        type: "warning",
        title: await window.API.translate("MR same name games title"),
        message: await window.API.translate("MR same name games message", {
            "desiredGame": desiredGameName,
            "gamelist": entryList
        }),
        buttons: buttonsList
    });

    // Return the game selected or null if no game is selected
    return result.button !== "close" ? listOfGames.find(x => x.id === parseInt(result.button)) : null;
}
//#endregion Adding game

//#region User Data
/**
 * @private
 * Obtain data of the logged user and show them in the custom element "user-info".
 */
async function getUserDataFromF95() {
    window.API.log.info("Retrieving user info from F95");

    // Retrieve user data
    const userdata = await window.F95.getUserData()
        .catch(e => window.API.reportError(e, "11225", "window.F95.getUserData", "getUserDataFromF95"));

    // Check user data
    if (!userdata) {
        // Hide spinner
        document.getElementById("user-info").hideSpinner();

        // Send error message
        const translation = await window.API.translate("MR cannot retrieve user data");
        sendToastToUser("error", translation);
        window.API.log.error("Something wrong while retrieving user info from F95");
        return;
    }

    // Update component
    document.getElementById("user-info").userdata = userdata;
    
    // Update threads
    await updatedThreads(userdata.watchedGameThreads);
}

//#endregion User Data

//#region Watched Threads
/**
 * @private
 * Process and show games not installed but in user watchlist that have undergone updates.
 * @param {String[]} watchedThreads List of URLs of watched game threads
 */
async function updatedThreads(watchedThreads) {
    // Store the new threads and obtains info on the updates
    await syncDatabaseWatchedThreads(watchedThreads)
        .catch(e => window.API.reportError(e, "11228", "syncDatabaseWatchedThreads", "updatedThreads"));

    // Obtains the updated threads to display to the user
    const updatedThreads = await getUpdatedThreads()
        .catch(e => window.API.reportError(e, "11229", "getUpdatedThreads", "updatedThreads"));

    // Prepare the threads tab
    window.requestAnimationFrame(() => prepareThreadUpdatesTab(updatedThreads));
}

/**
 * @private
 * Parse a F95Zone URL and return the ID.
 * @param {String} url 
 */
function getIDFromURL(url) {
    const match = url.match(/\.[0-9]+/);
    if(!match) return null;
    return parseInt(match[0].replace(".", ""));
}

/**
 * @private
 * Given a URL, insert into the thread database the data of the thread linked by the URL.
 * @param {String} url URL of the thread on the F95Zone platform
 */
async function insertThreadFromURL(url) {
    // Fetch the game data from the platform
    const gameInfo = await window.F95.getGameDataFromURL(url)
        .catch(e => window.API.reportError(e, "11230", "window.F95.getGameDataFromURL", "insertThreadFromURL", `URL: ${url}`));
    
    if(gameInfo) {
        // Convert object
        const threadInfo = window.TI.convert(gameInfo);
    
        // Insert in the database
        await window.ThreadDB.insert(threadInfo)
            .catch(e => window.API.reportError(e, "11231", "window.ThreadDB.insert", "insertThreadFromURL"));
    }
}

/**
 * @private
 * Given a URL, update the thread database with data of the thread linked by the URL.
 * @param {String} url URL of the thread on the F95Zone platform
 * @param {Number} tid ID of the thread in the database
 */
async function updateThreadInDB(url, tid) {
    // Fetch the game data from the platform
    const gameInfo = await window.F95.getGameDataFromURL(url)
        .catch(e => window.API.reportError(e, "11232", "window.F95.getGameDataFromURL", "updateThreadInDB", `URL: ${url}`));
        
    // Convert and update the thread data
    const threadInfo = window.TI.convert(gameInfo);
    threadInfo._id = tid; // Add the database ID
    threadInfo.updateAvailable = true;
    threadInfo.markedAsRead = false;
    
    // Update the DB record
    await window.ThreadDB.write(threadInfo)
        .catch(e => window.API.reportError(e, "11233", "window.ThreadDB.write", "updateThreadInDB"));
}

/**
 * @private
 * Remove from the thread database all the threads with ID not into the passed list.
 * @param {Number[]} recentIDs 
 */
async function removeUnsubscribedThreadsFromDB(recentIDs) {
    // Get all the threads from the database
    const threads = await window.ThreadDB.search({})
        .catch(e => window.API.reportError(e, "11234", "window.ThreadDB.search", "removeUnsubscribedThreadsFromDB"));
    
    // Filter the trhread and obtains the threads to remove
    const toRemove = threads.filter(t => !recentIDs.includes(t.id)).map(t => t.id);

    // Remove the threads from the db
    await window.ThreadDB.delete({id: {$in: toRemove}})
        .catch(e => window.API.reportError(e, "11235", "window.ThreadDB.delete", "removeUnsubscribedThreadsFromDB"));
}

/**
 * @private
 * Save the watched threads in the database and edit the updated threads.
 * @param {String[]} urlList List of URLs of watched game threads
 */
async function syncDatabaseWatchedThreads(urlList) {
    const recentIDs = [];
    for (const url of urlList) {
        // Extract the ID from the thread
        const id = getIDFromURL(url);
        if(id) {
            recentIDs.push(id);

            // Check if the thread exists in the database
            const thread = await window.ThreadDB.search({id: id})
                .catch(e => window.API.reportError(e, "11236", "window.ThreadDB.search", "syncDatabaseWatchedThreads"));

            if (thread.length === 0) await insertThreadFromURL(url);
            else if (thread[0].url !== url) await updateThreadInDB(url, thread[0]._id);
        }
    }

    // Remove the unsubscribed threads
    await removeUnsubscribedThreadsFromDB(recentIDs);
}

/**
 * @private
 * Obtains the updated and not read threads.
 * @return {Promise<ThreadInfo[]>} List of available threads
 */
async function getUpdatedThreads() {
    // Obtains the thread
    const threads = await window.ThreadDB.search({
        updateAvailable: true,
        markedAsRead: false
    }, {
        name: 1 // Order by name
    }).catch(e => window.API.reportError(e, "11237", "window.ThreadDB.search", "getUpdatedThreads"));

    // Excludes threads of installed games
    return await selecNonInstalledThreads(threads);
}

/**
 * @private
 * Select only the threads that doesn't have the game installed.
 * @param {ThreadInfo[]} threads 
 * @return {Promise<ThreadInfo[]>}
 */
async function selecNonInstalledThreads(threads) {
    const result = [];
    for (const thread of threads) {
        const count = await window.GameDB.count({id: thread.id})
            .catch(e => window.API.reportError(e, "11238", "window.GameDB.count", "selecNonInstalledThreads"));
        if (count === 0) result.push(thread);
    }
    return result;
}

/**
 * @private
 * Show the available threads in the DOM
 * @param {ThreadInfo[]} threads List of threads to show
 */
function prepareThreadUpdatesTab(threads) {
    // Local variables
    const visualizerTab = document.getElementById("main-updated-threads-tab");

    for (const thread of threads) {
        const threadVisualizer = document.createElement("thread-visualizer");
        threadVisualizer.info = thread;

        visualizerTab.appendChild(threadVisualizer);
    }
}
//#endregion Watched Threads

//#endregion Private methods

//#region IPC listeners
window.API.once("window-arguments", function (args) {
    // Set the checkbox for the menubar
    document.getElementById("settings-menubar-checkbox").checked = args["menubar"];

    // Set the checkbox for the open/copy link
    document.getElementById("settings-open-links-checkbox").checked = args["open-copy-links"];
});

/**
 * Updates the number of cards shown in the pager after the user resizes the window.
 */
window.API.receive("window-resized", function onWindowResized (size) {
    const paginator = document.querySelector("card-paginator");
    if (paginator) paginator.visibleCardsOnParentSize(size);
});
//#endregion IPC listeners
