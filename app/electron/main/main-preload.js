// For more information about secure use of IPC see:
// https://github.com/reZach/secure-electron-template/blob/master/docs/newtoelectron.md

"use strict";

// Core modules
const fs = require("fs");
const {
    glob
} = require("glob");
const {
    join,
    basename
} = require("path");

// Public modules from npm
const {
    contextBridge,
    ipcRenderer,
} = require("electron");
const download = require("image-downloader");
const logger = require("electron-log");

// Modules from file
const ioOps = require("../../src/scripts/io-operations.js");
const GameInfoExtended = require("../../src/scripts/classes/game-info-extended.js");
const ThreadInfo = require("../../src/scripts/classes/thread-info.js");
const networkHelper = require("../../src/scripts/network-helper.js");
const errManager = require("../../src/scripts/error-manger.js");

// Array of valid main-to-render channels
const validReceiveChannels = ["window-resized", "window-size", "window-arguments"];

// Array of valid render-to-main channels
const validSendChannels = [
    "login-required",
    "exec",
    "message-dialog",
    "open-dialog",
    "cwd",
    "cache-dir",
    "savegames-data-dir",
    "credentials-path",
    "translate",
    "require-messagebox",
    "url-input",
    "update-messagebox",
    "preview-dir",
    "app-version",
    "user-data",
    "window-size",
    "show-devtools",
    "allow-menubar",
    "open-copy-links"
];

//#region Error management
/**
 * @event
 * Handles errors generated by the application.
 * @param {String} message Error message
 * @param {String} source File where the error occurred
 * @param {number} lineno Line containing the instruction that generated the error
 * @param {number} colno Column containing the statement that generated the error
 * @param {Error} error Application generated error
 */
window.onerror = function (message, source, lineno, colno, error) {
    errManager.manageError("main-preload.js", {
        message: message,
        line: lineno,
        column: colno,
        error: error,
    }, ipcRenderer);
};

/**
 * @event
 * Handles errors generated within non-catched promises.
 * @param {PromiseRejectionEvent} error 
 */
window.onunhandledrejection = function (error) {
    errManager.manageUnhandledError("main-preload.js", error.reason, ipcRenderer);
};
//#endregion Error management

//#region Context Bridge
// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld("API", {
    /**
     * Directory of the app.js file.
     */
    appDir: __dirname.replace("electron", "").replace("main", ""),
    /**
     * Send an asynchronous request via IPC and wait for a response.
     * @param {String} channel Communication channel
     * @param {Any[]} data Data to send to main process
     * @returns {Promise<Any>} Result from the main process
     */
    invoke: (channel, ...data) => {
        // Send a custom message
        if (validSendChannels.includes(channel)) {
            return ipcRenderer.invoke(channel, data);
        } else logger.warn(`Unauthorized IPC message from 'main-preload.js' through ${channel}: ${data}`);
    },
    /**
     * Send an asynchronous request via IPC.
     * @param {String} channel Communication channel
     * @param {Any[]} data Data to send to main process
     */
    send: (channel, ...data) => {
        // Send a custom message
        if (validSendChannels.includes(channel)) {
            ipcRenderer.send(channel, data);
        } else logger.warn(`Unauthorized IPC message from 'main-preload.js' through ${channel}: ${data}`);
    },
    /**
     * Receive a message from main process via IPC and execute a method.
     * @param {String} channel Communication channel
     * @param {Function} func Method to execute when a message is received
     */
    receive: (channel, func) => {
        // Receive a custom message
        if (validReceiveChannels.includes(channel)) {
            // Deliberately strip event as it includes `sender`
            ipcRenderer.on(channel, (_, ...args) => func(...args));
        }
    },
    once: (channel, func) => {
        // Receive a custom message
        if (validReceiveChannels.includes(channel)) {
            // Deliberately strip event as it includes `sender`
            ipcRenderer.once(channel, (_, ...args) => func(...args));
        }
    },
    /**
     * Join multiple strings into a parsed path for the current OS.
     * @param {String[]} paths Partial paths to join
     * @return {String} Joined path
     */
    join: (...paths) => join(...paths),
    /**
     * Check if an Internet connection is available
     */
    isOnline: () => networkHelper.checkConnection(),
    /**
     * Download an image given a url.
     * @param {String} url URL to download the image from
     * @param {String} dest Path where save the image
     */
    downloadImage: function apiDownloadImage(url, dest) {
        return download.image({
            url: url,
            dest: dest,
        });
    },
    /**
     * Return the last portion of a path.
     * @param {String} path
     * @returns {String}
     */
    basename: function apiGetDirName(path) {
        return basename(path);
    },
    /**
     * Provide access to logger methods.
     */
    log: logger.functions,
    /**
     * Translate a key into a message in the language specified by the user.
     * @param {String} key Unique key of the message
     * @param {Object} interpolation Dictionary containing the interpolation values
     * @returns {Promise<String>}
     */
    translate: async function apiTranslate(key, interpolation) {
        return ipcRenderer.invoke("translate", key, interpolation);
    },
    /**
     * Change the displayed language in the app.
     * @param {String} iso ISO 639-1 language
     */
    changeLanguage: async function apiChangeLanguage(iso) {
        return ipcRenderer.invoke("change-language", iso);
    },
    /**
     * Get the current app language ISO-code
     */
    currentLanguage: async function apiCurrentLanguage() {
        return ipcRenderer.invoke("current-language");
    },
    /**
     * Log an error
     * @param {Error} error Throwed error
     * @param {String} code Unique error code
     * @param {String} name Name of the function that throw the error
     * @param {String} parentName Name of the function containing the error throwing function
     * @param {String} message Custom message to add
     */
    reportError: (error, code, name, parentName, message) => errManager.reportError(error, code, name, parentName, message),
});

// Expose the I/O operations
contextBridge.exposeInMainWorld("IO", {
    /**
     * Read data from a file synchronously.
     * @param {String} path
     * @returns {Any}
     */
    readSync: function ioReadSync(path) {
        return ioOps.readFileSync(path);
    },
    /**
     * Read data from a file asynchronously.
     * @param {String} path
     * @returns {Any}
     */
    read: async function ioRead(path) {
        return ioOps.readFileSync(path);
    },
    /**
     * Write data in a file.
     * @param {String} path
     * @param {Any} value
     */
    write: async function ioWrite(path, value) {
        fs.writeFileSync(path, value);
    },
    /**
     * Filter a direcotry using glob.
     * @param {String} filter Glob filter
     * @param {String} basedir Path to the directory where starting using the filter
     * @returns {Promise<String[]>} List of files matching the filter
     */
    filter: async function ioFilter(filter, basedir) {
        return glob.sync(filter, {
            cwd: basedir,
        });
    },
    /**
     * Remove a single file from disk.
     * @param {String} filename Path to the file
     */
    deleteFile: function ioDeleteFile(filename) {
        fs.unlinkSync(filename);
    },
    /**
     * Remove a dirctory recursively, unlinking also the content.
     * @param {String} dirname Path of the directory
     */
    deleteFolder: async function ioDeleteFolder(dirname) {
        ioOps.deleteFolderRecursive(dirname);
    },
    /**
     * Check if the path exists on disk.
     * @param {String} path
     * @returns {Boolean}
     */
    pathExists: async function ioPathExists(path) {
        return ioOps.exists(path);
    },
    /**
     * Rename a directory.
     * @param {String} currPath Current path of the directory
     * @param {String} newPath Path of the directory with the new name
     */
    renameDir: function ioRenameDir(currPath, newPath) {
        fs.renameSync(currPath, newPath);
    },
    /**
     * Create a directory.
     * @param {String} dirname Path to new dir
     */
    mkdir: async function ioMkdir(dirname) {
        if (!fs.existsSync(dirname))
            fs.mkdirSync(dirname, {
                recursive: true,
            });
    },
    /**
     * Copy a file.
     * @param {String} src Path to origin
     * @param {String} dest Path to new destination
     */
    copy: async function ioCopy(src, dest) {
        fs.copyFileSync(src, dest);
    },
});

// Expose the F95API
contextBridge.exposeInMainWorld("F95", {
    logged: () => ipcRenderer.invoke("f95api", "isLogged"),
    login: (username, password) => ipcRenderer.invoke("f95api", "login", {
        username: username,
        password: password
    }),
    getUserData: () => ipcRenderer.invoke("f95api", "getUserData"),
    getGameData: (name, searchMod) => ipcRenderer.invoke("f95api", "getGameData", {
        name: name,
        searchMod: searchMod
    }),
    getGameDataFromURL: (url) => ipcRenderer.invoke("f95api", "getGameDataFromURL", {
        url: url
    }),
    checkGameUpdates: (data) => ipcRenderer.invoke("f95api", "checkGameUpdates", {
        gameinfo: data
    })
});

// Expose the GameInfoExtended custom class
contextBridge.exposeInMainWorld("GIE", {
    gamedata: new GameInfoExtended(),
    convert: function convert(gameinfo) {
        // Create a new object from the data
        return Object.assign(new GameInfoExtended(), gameinfo);
    },
    saves: async function getGameSaves(data) {
        // Create a new object from the data
        const gameinfo = Object.assign(new GameInfoExtended(), data);

        return await gameinfo.getSaves();
    },
    launcher: function getGameLauncher(data) {
        // Create a new object from the data
        const gameinfo = Object.assign(new GameInfoExtended(), data);

        return gameinfo.getGameLauncher();
    }
});

// Expose the ThreadInfo custom class
contextBridge.exposeInMainWorld("TI", {
    threadinfo: new ThreadInfo(),
    convert: (gameinfo) => threadConvert(gameinfo),
    syncThreadsDB: () => updateLocalThreads()
});

// Expose methods for error logging
contextBridge.exposeInMainWorld("EM", {
    onerror: (scriptname, data) => errManager.manageError(scriptname, data, ipcRenderer),
    unhandlederror: (scriptname, reason) => errManager.manageUnhandledError(scriptname, reason, ipcRenderer)
});

// Wrapper around the Game DB operations
contextBridge.exposeInMainWorld("GameDB", {
    insert: (gameinfo) => ipcRenderer.invoke("database-operation", "game", "insert", {
        data: gameinfo
    }),
    delete: (deleteQuery) => ipcRenderer.invoke("database-operation", "game", "delete", {
        query: deleteQuery
    }),
    read: (id) => ipcRenderer.invoke("database-operation", "game", "read", {
        id: id
    }),
    write: (gameinfo) => ipcRenderer.invoke("database-operation", "game", "write", {
        data: gameinfo
    }),
    search: (searchQuery, sortQuery, index, size, limit) => ipcRenderer.invoke("database-operation", "game", "search", {
        query: searchQuery,
        pagination: {
            index: index,
            size: size,
            limit: limit
        },
        sortQuery: sortQuery ? sortQuery : {}
    }),
    count: (query) => ipcRenderer.invoke("database-operation", "game", "count", {
        query: query
    }),
});

// Wrapper around the Thread DB operations
contextBridge.exposeInMainWorld("ThreadDB", {
    insert: (threadinfo) => threadInsertInDB(threadinfo),
    delete: (deleteQuery) => threadDeleteFromDB(deleteQuery),
    write: (threadinfo) => threadWriteInDB(threadinfo),
    search: (searchQuery, sortQuery, index, size, limit) => threadSearchInDB(searchQuery, sortQuery, index, size, limit),
});

// Wrapper around the Update DB operations
contextBridge.exposeInMainWorld("UpdateDB", {
    insert: (gameinfo) => ipcRenderer.invoke("database-operation", "update", "insert", {
        data: gameinfo
    }),
    delete: (deleteQuery) => ipcRenderer.invoke("database-operation", "update", "delete", {
        query: deleteQuery
    }),
    search: (searchQuery, sortQuery, index, size, limit) => ipcRenderer.invoke("database-operation", "update", "search", {
        query: searchQuery,
        pagination: {
            index: index,
            size: size,
            limit: limit
        },
        sortQuery: sortQuery ? sortQuery : {}
    }),
});
//#endregion Context Bridge

//#region Private methods
function threadConvert(gameinfo) {
    const threadInfo = new ThreadInfo();
    threadInfo.fromGameInfo(gameinfo);

    return threadInfo;
}

function threadSearchInDB(searchQuery, sortQuery, index, size, limit) {
    return ipcRenderer.invoke("database-operation", "thread", "search", {
        query: searchQuery,
        pagination: {
            index: index,
            size: size,
            limit: limit
        },
        sortQuery: sortQuery ? sortQuery : {}
    })
}

function threadDeleteFromDB(deleteQuery) {
    return ipcRenderer.invoke("database-operation", "thread", "delete", {
        query: deleteQuery
    })
}

function threadInsertInDB(threadinfo) {
    return ipcRenderer.invoke("database-operation", "thread", "insert", {
        data: threadinfo
    });
}

function threadWriteInDB(threadinfo) {
    return ipcRenderer.invoke("database-operation", "thread", "write", {
        data: threadinfo
    });
}

function sliceIntoChunks(arr, chunkSize) {
    const res = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
        const chunk = arr.slice(i, i + chunkSize);
        res.push(chunk);
    }
    return res;
}

async function saveThreadInDatabase(url) {
    // Get the thread ID
    const id = getIDFromURL(url);
    if (!id) return null;

    // Fetch the game data from the platform
    const gameInfo = await ipcRenderer.invoke("f95api", "getGameDataFromURL", {
        url: url
    });
    if (!gameInfo) return null;

    // Check if the thread exists in the database
    const thread = await threadSearchInDB({
        id: id
    });

    if (thread.length === 0) await insertThreadInDB(gameInfo);
    else if (thread[0].version !== gameInfo.version) await updateThreadInDB(gameInfo, thread[0]._id);

    return id;
}

async function updateLocalThreads() {
    // Get the data of the current user
    const userdata = await ipcRenderer.invoke("f95api", "getUserData");

    // Get the watched game threads
    const urls = userdata._watched.filter((wt) => wt.forum === "Games").map((wt) => wt.url);

    // Divide the array in chunks
    const chunks = sliceIntoChunks(urls, 30);

    // Get all the watched threads and save them into the database
    const ids = [];
    for (const chunk of chunks) {
        const promises = chunk.map((url) => saveThreadInDatabase(url));
        const chunkIDs = (await Promise.all(promises)).filter((id) => id !== null);
        ids.push(...chunkIDs);
    }

    // Remove all the unwatched (unsubscribed) threads in the database
    await removeUnsubscribedThreadsFromDB(ids);
}

/**
 * @private
 * Remove from the thread database all the threads with ID not into the passed list.
 * @param {Number[]} recentIDs 
 */
async function removeUnsubscribedThreadsFromDB(recentIDs) {
    // Get all the threads from the database
    const threads = await threadSearchInDB({});

    // Filter the threads and obtains the threads to remove
    const toRemove = threads.filter(t => !recentIDs.includes(t.id)).map(t => t.id);

    // Remove the threads from the db
    await threadDeleteFromDB({
            id: {
                $in: toRemove
            }
        });
}

/**
 * @private
 * Parse a F95Zone URL and return the ID.
 * @param {String} url 
 */
function getIDFromURL(url) {
    const match = url.match(/\.[0-9]+/);
    if (!match) return null;
    return parseInt(match[0].replace(".", ""));
}

/**
 * @private
 * Given a URL, insert into the thread database the data of the thread linked by the URL.
 * @param {GameInfo} gameinfo Game to insert in the DB
 */
async function insertThreadInDB(gameinfo) {
    // Convert object
    const threadInfo = threadConvert(gameinfo);

    // Insert in the database
    await threadInsertInDB(threadInfo);
}

/**
 * @private
 * Given a URL, update the thread database with data of the thread linked by the URL.
 * @param {GameInfo} gameinfo Game to update in the DB
 * @param {Number} tid ID of the thread in the database
 */
async function updateThreadInDB(gameinfo, tid) {
    // Convert and update the thread data
    const threadInfo = threadConvert(gameinfo);
    threadInfo._id = tid; // Add the database ID
    threadInfo.updateAvailable = true;
    threadInfo.markedAsRead = false;

    // Update the DB record
    await threadWriteInDB(threadInfo)
}
//#endregion Private methods
